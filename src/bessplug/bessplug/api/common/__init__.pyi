"""
Common bindings
"""
from __future__ import annotations
import collections.abc
import typing
from . import theme
from . import time
__all__: list[str] = ['StringViewArray1', 'UUID', 'theme', 'time', 'vec2', 'vec3', 'vec4']
class StringViewArray1:
    def __getitem__(self: typing.Annotated[collections.abc.Sequence[str], "FixedSize(1)"], arg0: typing.SupportsInt) -> str:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self: typing.Annotated[collections.abc.Sequence[str], "FixedSize(1)"]) -> collections.abc.Iterator[str]:
        ...
    def __len__(self: typing.Annotated[collections.abc.Sequence[str], "FixedSize(1)"]) -> int:
        ...
    def __repr__(self: typing.Annotated[collections.abc.Sequence[str], "FixedSize(1)"]) -> str:
        ...
class UUID:
    __hash__: typing.ClassVar[None] = None
    null: typing.ClassVar[UUID]  # value = <UUID 0>
    def __eq__(self, arg0: UUID) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, id: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: UUID) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, arg0: UUID) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class vec2:
    def __add__(self, arg0: vec2) -> vec2:
        ...
    def __eq__(self, arg0: vec2) -> bool:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, x: typing.SupportsFloat, y: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, seq: collections.abc.Sequence) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __mul__(self, arg0: typing.SupportsFloat) -> vec2:
        ...
    def __ne__(self, arg0: vec2) -> bool:
        ...
    def __neg__(self) -> vec2:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> vec2:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: vec2) -> vec2:
        ...
    def __truediv__(self, arg0: typing.SupportsFloat) -> vec2:
        ...
    def to_tuple(self) -> tuple:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg0: typing.SupportsFloat) -> None:
        ...
class vec3:
    __hash__: typing.ClassVar[None] = None
    def __add__(self, arg0: vec3) -> vec3:
        ...
    def __eq__(self, arg0: vec3) -> bool:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, seq: collections.abc.Sequence) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __mul__(self, arg0: typing.SupportsFloat) -> vec3:
        ...
    def __ne__(self, arg0: vec3) -> bool:
        ...
    def __neg__(self) -> vec3:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> vec3:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: vec3) -> vec3:
        ...
    def __truediv__(self, arg0: typing.SupportsFloat) -> vec3:
        ...
    def copy(self) -> vec3:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def z(self) -> float:
        ...
    @z.setter
    def z(self, arg0: typing.SupportsFloat) -> None:
        ...
class vec4:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat, w: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, seq: collections.abc.Sequence) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def w(self) -> float:
        ...
    @w.setter
    def w(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def x(self) -> float:
        ...
    @x.setter
    def x(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def y(self) -> float:
        ...
    @y.setter
    def y(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def z(self) -> float:
        ...
    @z.setter
    def z(self, arg0: typing.SupportsFloat) -> None:
        ...
